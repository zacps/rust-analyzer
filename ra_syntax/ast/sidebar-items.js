initSidebarItems({"enum":[["ArrayExprKind",""],["AssocItem","Any kind of item that may appear in an impl block"],["AttrInput","Any kind of input to an attribute"],["AttrKind",""],["BinOp",""],["CommentPlacement",""],["CommentShape",""],["Effect",""],["ElseBranch",""],["Expr","Any kind of expression"],["ExternItem","Any kind of item that may appear in an extern block"],["FieldDefList","Any kind of fields list (record or tuple field lists)"],["FieldKind",""],["FormatSpecifier",""],["GenericArg","Any kind of generic argument passed at instantiation site"],["GenericParam","Any kind of declared generic parameter"],["LiteralKind",""],["ModuleItem","Any kind of top-level item that may appear in a module"],["NameOrNameRef",""],["NominalDef","Any kind of nominal type definition."],["Pat","Any kind of pattern"],["PathSegmentKind",""],["PrefixOp",""],["RangeOp",""],["RecordInnerPat","Any kind of pattern that appears directly inside of the curly braces of a record pattern"],["SelfParamKind",""],["Stmt","Any kind of statement Note: there are no empty statements, these are just represented as bare semicolons without a dedicated statement ast node."],["StructKind",""],["TypeBoundKind",""],["TypeRef","Any kind of construct valid in type context"],["VisibilityKind",""]],"mod":[["edit","This module contains functions for editing syntax trees. As the trees are immutable, all function here return a fresh copy of the tree, instead of doing an in-place modification."],["make","This module contains free-standing functions for creating AST fragments out of smaller pieces."]],"struct":[["Abi","Abi declaration. Note: the abi string is optional."],["Alias","Item alias. Note: this is not the type alias."],["ArgList","Call site arguments list."],["ArrayExpr","Array literal."],["ArrayType","Array type."],["AssocTypeArg","Associated type argument that is passed at generic instantiation site. ``` type Foo = Bar::<'a, u64, bool, ❰ Item = Baz ❱, 42>::Bruh;"],["AstChildren","An iterator over `SyntaxNode` children of a particular AST type."],["Attr","Attribute."],["AwaitExpr","Await operator call expression."],["BinExpr","Binary operator call. Includes all arithmetic, logic, bitwise and assignment operators."],["BindPat","Bind pattern."],["BlockExpr","Block expression. Includes unsafe blocks and block labels."],["BoxExpr","Box operator call."],["BoxPat","Box pattern."],["BreakExpr","Break expression."],["CallExpr","Call expression (not to be confused with method call expression, it is a separate ast node)."],["CastExpr","Type cast expression."],["Comment",""],["CommentIter",""],["CommentKind",""],["Condition","Condition of `if` or `while` expression."],["ConstArg","Constant value argument that is passed at generic instantiation site."],["ConstDef","Constant variable definition. Includes all of its attributes and doc comments."],["ConstParam","Const generic parameter declaration. `fn foo<T, U, ❰ const BAR: usize ❱, ❰ const BAZ: bool ❱>() {}`"],["ContinueExpr","Continue expression."],["DotDotPat","Rest-of-the record/tuple pattern. Note: this is not the unbonded range pattern (even more: it doesn't exist)."],["DynTraitType","Trait object type."],["EffectExpr","Block expression with an optional prefix (label, try ketword, unsafe keyword, async keyword...)."],["EnumDef","Enum definition. Includes all of its attributes and doc comments."],["EnumVariant","Enum variant definition including its attributes and discriminant value definition."],["EnumVariantList","Enum variant definition list including enclosing curly braces."],["ExprStmt","Expression statement."],["ExternBlock","Extern block."],["ExternCrateItem","Extern crate item."],["ExternItemList","List of items in an extern block."],["FieldExpr","Field access expression."],["FnDef","Function definition either with body or not. Includes all of its attributes and doc comments."],["FnPointerType","Function pointer type (not to be confused with `Fn*` family of traits)."],["ForExpr","For loop expression. Note: record struct literals are not valid as iterable expression due to ambiguity."],["ForType","Higher order type."],["IfExpr","If expression. Includes both regular `if` and `if let` forms. Beware that `else if` is a special case syntax sugar, because in general there has to be block expression after `else`."],["ImplDef","Inherent and trait impl definition. Includes all of its inner and outer attributes."],["ImplTraitType","Opaque `impl Trait` type."],["IndexExpr","Index expression a.k.a. subscript operator call."],["ItemList","Item defintion list. This is used for both top-level items and impl block items."],["Label","Label."],["LambdaExpr","Anonymous callable object literal a.k.a. closure, lambda or functor."],["LetStmt","Let statement."],["LifetimeArg","Lifetime argument that is passed at generic instantiation site."],["LifetimeParam","Lifetime parameter declaration."],["Literal","[Raw] string, [raw] byte string, char, byte, integer, float or bool literal."],["LiteralPat","Literal pattern. Includes only bool, number, char, and string literals."],["LoopExpr","Unconditional loop expression."],["MacroCall","Macro call. Includes all of its attributes and doc comments."],["MacroDef","Macro 2.0 definition. Their syntax is still WIP by rustc team... `❰     macro foo { } ❱`"],["MacroItems","FIXME: (@edwin0cheng) Remove it to use ItemList instead https://github.com/rust-analyzer/rust-analyzer/pull/4083#discussion_r422666243"],["MacroPat","Macro invocation in pattern position."],["MacroStmts","FIXME: (@edwin0cheng) add some documentation here. As per the writing of this comment this ast node is not used."],["MatchArm","Match arm. Note: record struct literals are not valid as target match expression due to ambiguity. `match expr {     ❰ #[attr] Pattern(it) if bool_cond => it ❱, }`"],["MatchArmList","Match arm list part of match expression. Includes its inner attributes."],["MatchExpr","Match expression."],["MatchGuard","Match guard."],["MetaItem","Meta item in an attribute."],["MethodCallExpr","Method call expression."],["Module","Module definition either with body or not. Includes all of its inner and outer attributes, module items, doc comments."],["Name","Single identifier. Note(@matklad): `Name` is for things that install a new name into the scope, `NameRef` is a usage of a name. Most of the time, this definition/reference distinction can be determined purely syntactically, ie in `fn foo() { foo() }` the first foo is `Name`, the second one is `NameRef`. The notable exception are patterns, where in `` let x = 92 ``` `x` can be semantically either a name or a name ref, depeding on wether there's an `x` constant in scope. We use `Name` for patterns, and disambiguate semantically (see `NameClass` in ide_db)."],["NameRef","Reference to a name. See the explanation on the difference between `Name` and `NameRef` in `Name` ast node docs."],["NeverType","The never type (i.e. the exclamation point)."],["OrPat","Disjunction of patterns."],["Param","Parameter declaration."],["ParamList","Parameter list declaration."],["ParenExpr","Parenthesized expression. Note: parens are only used for grouping, this is not a tuple literal."],["ParenPat","Parenthesized pattern. Note: parens are only used for grouping, this is not a tuple pattern."],["ParenType","Parenthesized type reference. Note: parens are only used for grouping, this is not a tuple type."],["Path","Path to a symbol. Includes single identifier names and elaborate paths with generic parameters."],["PathExpr","Path to a symbol in expression context. Includes single identifier variable names and elaborate paths with generic parameters."],["PathPat","Path pattern. Doesn't include the underscore pattern (it is a special case, namely `PlaceholderPat`)."],["PathSegment","Segment of the path to a symbol. Only path segment of an absolute path holds the `::` token, all other `::` tokens that connect path segments reside under `Path` itself.`"],["PathType","Path to a type. Includes single identifier type names and elaborate paths with generic parameters."],["PlaceholderPat","Placeholder pattern a.k.a. the wildcard pattern or the underscore."],["PlaceholderType","Placeholder type (i.e. the underscore)."],["PointerType","Raw pointer type."],["PrefixExpr","Prefix operator call. This is either `!` or `*` or `-`."],["QuoteOffsets",""],["RangeExpr","Range operator call."],["RangePat","Range pattern."],["RawString",""],["RecordField","Record field."],["RecordFieldDef","Record field definition including its attributes and doc comments."],["RecordFieldDefList","Record field definition list including enclosing curly braces."],["RecordFieldList","Record field list including enclosing curly braces."],["RecordFieldPat","Record literal's field pattern. Note: record literal can also match tuple structs."],["RecordFieldPatList","Record literal's field patterns list including enclosing curly braces."],["RecordLit","Record literal expression. The same syntax is used for structs, unions and record enum variants."],["RecordPat","Record literal pattern."],["RefExpr","Borrow operator call."],["RefPat","Reference pattern. Note: this has nothing to do with `ref` keyword, the latter is used in bind patterns."],["ReferenceType","Reference type."],["RetType","Return type annotation."],["ReturnExpr","Return expression."],["SelfParam","Self parameter declaration."],["SlicePat","Slice pattern."],["SlicePatComponents",""],["SliceType","Slice type."],["SourceFile","The entire Rust source file. Includes all top-level inner attributes and module items."],["StaticDef","Static variable definition. Includes all of its attributes and doc comments."],["String",""],["StructDef","Struct definition. Includes all of its attributes and doc comments."],["TokenTree","Stores a list of lexer tokens and other `TokenTree`s. It appears in attributes, macro_rules and macro call (foo!)"],["TraitDef","Trait definition. Includes all of its attributes and doc comments."],["TryExpr","The question mark operator call."],["TupleExpr","Tuple literal."],["TupleFieldDef","Tuple field definition including its attributes."],["TupleFieldDefList","Tuple field definition list including enclosing parens."],["TuplePat","Tuple pattern. Note: this doesn't include tuple structs (see `TupleStructPat`)"],["TupleStructPat","Tuple struct literal pattern."],["TupleType","Unnamed tuple type."],["TypeAliasDef","Type alias definition. Includes associated type clauses with type bounds."],["TypeArg","Type argument that is passed at generic instantiation site."],["TypeArgList","List of type arguments that are passed at generic instantiation site."],["TypeBound","Type bound declaration clause."],["TypeBoundList","Type bounds list."],["TypeParam","Single type parameter declaration."],["TypeParamList","Generic lifetime, type and constants parameters list declaration."],["UnionDef","Union definition. Includes all of its attributes and doc comments."],["UseItem","Use declaration."],["UseTree","Use tree."],["UseTreeList","Sublist of use trees."],["Visibility","Visibility."],["WhereClause","Where clause."],["WherePred","Single where predicate."],["WhileExpr","While loop expression. Includes both regular `while` and `while let` forms."],["Whitespace",""]],"trait":[["ArgListOwner",""],["AstNode","The main trait to go from untyped `SyntaxNode`  to a typed ast. The conversion itself has zero runtime cost: ast and syntax nodes have exactly the same representation: a pointer to the tree root and a pointer to the node itself."],["AstToken","Like `AstNode`, but wraps tokens rather than interior nodes."],["AttrsOwner",""],["DocCommentsOwner",""],["HasFormatSpecifier",""],["HasQuotes",""],["HasStringValue",""],["LoopBodyOwner",""],["ModuleItemOwner",""],["NameOwner",""],["TypeAscriptionOwner",""],["TypeBoundsOwner",""],["TypeParamsOwner",""],["VisibilityOwner",""]]});